let Post,mongoose,Joi,posts;_9e1‍.x([["getPostById",()=>getPostById],["write",()=>write],["list",()=>list],["read",()=>read],["remove",()=>remove],["update",()=>update]]);_9e1‍.w("../../models/post",[["default",["Post"],function(v){Post=v}]]);_9e1‍.w("mongoose",[["default",["mongoose"],function(v){mongoose=v}]]);_9e1‍.w("joi",[["default",["Joi"],function(v){Joi=v}]]);_9e1‍.w("./index",[["default",["posts"],function(v){posts=v}]]);




const {ObjectId} = _9e1‍.a("mongoose",mongoose).Types;

       const getPostById = async (ctx, next) => {
  const {id} = ctx.params;
  if (!ObjectId.isValid(id)) {
    ctx.status = 400; // Bad Request
    return;
  }
  try {
    const post = await _9e1‍.a("Post",Post).findById(id);
    //포스트가 존재하지 않을 떄
    if (!post) {
      ctx.status = 404;
      return;
    }
    ctx.state.post = post;
    return next();
  } catch (e) {
    ctx.throw(500, e);
  }
};;_9e1‍.j(["getPostById"]);

/*
POST /api/posts
{
 title: '제목',
 body: '내용',
 tags:  ['태그1','태그2']
*/
       const write = async ctx => {
  const schema = _9e1‍.a("Joi",Joi).object().keys({
    // 객체가 다음 필드를 가지고 있음을 검증
    title: _9e1‍.a("Joi",Joi).string().required(),
    body: _9e1‍.a("Joi",Joi).string().required(),
    tags: _9e1‍.a("Joi",Joi).array()
    .items(_9e1‍.a("Joi",Joi).string())
    .required(),
  }); // 문자열로 이루어진 배열

  // 검증하고 나서 검증 실패인 경우 에러 처리
  const result = schema.validate(ctx.request.body);
  if (result.error) {
    ctx.status = 400; //Bad Request
    ctx.body = result.error;
    return;
  }

  const {title, body, tags} = ctx.request.body;
  const post = new (_9e1‍.a("Post",Post))({
    title,
    body,
    tags,
    user: ctx.state.user,
  });
  try {
    await post.save();
    ctx.body = post;
  } catch (e) {
    ctx.throw(500, e);
  }
};;_9e1‍.j(["write"]);

/*
GET /api/posts
 */
       const list = async ctx => {
  // query는 문자열이기 때문에 숫자로 변환해 주어야 함
  // 값이 주어지지 않았다면 1을 기본으로 사용
  const page = parseInt(ctx.query.page || '1', 10);
  if (page < 1) {
    ctx.status = 400;
    return;
  }

  try {
    const posts = await _9e1‍.a("Post",Post).find()
    .sort({_id: -1})
    .limit(10)
    .skip((page - 1) * 10)
    .exec();
    const postCount = await _9e1‍.a("Post",Post).countDocuments().exec();
    ctx.set('Last-Page', Math.ceil(postCount / 10));
    ctx.body = posts
    .map(post => post.toJSON())
    .map(post => ({
      ...post,
      body: post.body.length < 200 ? post.body : `${post.body.slice(0,
          200)}...`,
    }));
  } catch (e) {
    ctx.throw(500, e);
  }
};;_9e1‍.j(["list"]);

/*
GET /api/posts/:id
 */
       const read = async ctx => {
  const {id} = ctx.params;
  try {
    const post = await _9e1‍.a("Post",Post).findById(id).exec();
    if (!post) {
      ctx.status = 404; //  Not Found
      return;
    }
    ctx.body = post;
  } catch (e) {
    ctx.throw(500, e);
  }
};;_9e1‍.j(["read"]);

/*
DELETE /api/posts/:id
 */
       const remove = async ctx => {
  const {id} = ctx.params;
  try {
    await _9e1‍.a("Post",Post).findByIdAndRemove(id).exec();
    ctx.status = 204; // No Content (성공 했지만 데이터가 없음)
  } catch (e) {
    ctx.throw(500, e);
  }
};;_9e1‍.j(["remove"]);

/*
PATCH /api/posts/:id
{
title:'수정',
body:'수정 내용',
tags: ['수정','태그']
 */
       const update = async ctx => {
  const {id} = ctx.params;
  // write에서 사용한 schema와 비슷 하지만 required()없음
  const schema = _9e1‍.a("Joi",Joi).object().keys({
    title: _9e1‍.a("Joi",Joi).string(),
    body: _9e1‍.a("Joi",Joi).string(),
    tags: _9e1‍.a("Joi",Joi).array().items(_9e1‍.a("Joi",Joi).string()),
  });

  // 검증하고 나서 검증 실패인 경우 에러 처리
  const result = schema.validate(ctx.request.body);
  if (result.error) {
    ctx.status = 400; // Bad Request
    ctx.body = result.error;
    return;
  }
  try {
    const post = await _9e1‍.a("Post",Post).findByIdAndUpdate(id, ctx.request.body, {
      new: true,
    }).exec();
    if (!post) {
      ctx.status = 404;
      return;
    }
    ctx.body = post;
  } catch (e) {
    ctx.throw(500, e);
  }
};;_9e1‍.j(["update"]);